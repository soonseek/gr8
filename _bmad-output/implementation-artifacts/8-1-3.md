# Story 8-1-3: JWT 토큰 관리 및 갱신 (JWT Token Management)

Status: done
Priority: MEDIUM

## Story

**As a** 사용자,
**I want** JWT 토큰이 만료되기 전에 자동으로 갱신되고 싶다,
**So that** 세션 중에 갑자기 로그아웃되지 않는다.

## 배경 (Context)

**문제:**
- JWT 토큰은 24시간 유효
- 24시간이 지나면 토큰이 만료되어 자동 로그아웃됨
- 사용자는 수동으로 다시 지갑 연결해야 함
- 긴 세션을 유지해야 하는 사용자 경험 저하

**해결:**
토큰 만료 전 자동 갱신 및 만료 시 우아한 처리

## 수용 기준 (Acceptance Criteria)

### AC 1: 토큰 만료 감지

**Given** JWT 토큰이 24시간 유효할 때
**When** API 요청을 보내면
**Then** 토큰 만료 시간을 확인한다
**And** 만료 1시간 전이면 자동 갱신을 시도한다

### AC 2: 자동 토큰 갱신

**Given** 토큰이 곧 만료될 때 (만료 1시간 전)
**When** 백엔드 API를 호출하면
**Then** 먼저 토큰 갱신 요청을 보낸다
**And** 새로운 JWT 토큰을 발급받는다
**And** localStorage를 업데이트한다
**And** 원래 API 요청을 새 토큰으로 다시 보낸다

### AC 3: 만료 토큰 처리

**Given** 토큰이 이미 만료되었을 때
**When** API 요청을 보내면
**Then** 401 Unauthorized 응답을 받는다
**And** "세션이 만료되었습니다. 다시 로그인해주세요" 메시지를 표시한다
**And** 로그인 페이지로 리디렉션한다
**And** localStorage에서 토큰을 삭제한다

### AC 4: 백엔드 토큰 갱신 API

**Given** 유효한 JWT 토큰이 있을 때
**When** POST /api/auth/refresh를 호출하면
**Then** 새로운 JWT 토큰을 발급한다
**And** 새 토큰의 만료 시간은 24시간이다

## 기술 구현 (Technical Implementation)

### 백엔드: 토큰 갱신 API

**파일:** `gr8-backend/app/api/routers/auth.py` (추가)

```python
@router.post("/api/auth/refresh")
async def refresh_token(
    token: str,
    db: AsyncSession = Depends(get_db)
):
    """JWT 토큰 갱신"""

    # 기존 토큰 디코딩
    payload = decode_jwt(token)

    if not payload:
        raise HTTPException(status_code=401, detail="Invalid token")

    wallet_address = payload.get("wallet_address")

    # 사용자 확인
    result = await db.execute(
        select(User).where(User.wallet_address == wallet_address)
    )
    user = result.scalar_one_or_none()

    if not user:
        raise HTTPException(status_code=401, detail="User not found")

    # 새 토큰 생성
    new_token = create_access_token(wallet_address)

    return {
        "access_token": new_token,
        "token_type": "bearer",
        "expires_in": 86400  # 24시간 (초)
    }
```

### 프론트엔트: 토큰 관리자

**파일:** `gr8-frontend/src/utils/tokenManager.ts`

```typescript
export class TokenManager {
  private readonly TOKEN_KEY = 'access_token'
  private readonly REFRESH_THRESHOLD = 60 * 60 * 1000  // 1시간 (밀리초)

  getToken(): string | null {
    return localStorage.getItem(this.TOKEN_KEY)
  }

  setToken(token: string): void {
    localStorage.setItem(this.TOKEN_KEY, token)
  }

  clearToken(): void {
    localStorage.removeItem(this.TOKEN_KEY)
  }

  // 토큰 만료까지 남은 시간 (밀리초)
  getTimeUntilExpiry(token: string): number {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]))
      const exp = payload.exp * 1000  // 초 → 밀리초
      return exp - Date.now()
    } catch {
      return 0  // 파싱 실패 = 만료로 간주
    }
  }

  // 갱신 필요 여부 확인 (만료 1시간 전)
  shouldRefresh(token: string | null): boolean {
    if (!token) return false

    const timeLeft = this.getTimeUntilExpiry(token)
    return timeLeft > 0 && timeLeft < this.REFRESH_THRESHOLD
  }

  // 토큰 만료 여부 확인
  isExpired(token: string | null): boolean {
    if (!token) return true

    const timeLeft = this.getTimeUntilExpiry(token)
    return timeLeft <= 0
  }
}

export const tokenManager = new TokenManager()
```

### 프론트엔드: Axios 인터셉터

**파일:** `gr8-frontend/src/utils/api.ts`

```typescript
import axios, { AxiosError } from 'axios'
import { tokenManager } from './tokenManager'

// Axios 인스턴스 생성
export const api = axios.create({
  baseURL: 'http://localhost:8000/api',
  timeout: 10000
})

// 요청 인터셉터 (토큰 자동 갱신)
api.interceptors.request.use(
  async (config) => {
    const token = tokenManager.getToken()

    // 토큰이 있고 갱신이 필요하면 먼저 갱신
    if (token && tokenManager.shouldRefresh(token)) {
      try {
        const newToken = await refreshToken()
        tokenManager.setToken(newToken)
        config.headers['Authorization'] = `Bearer ${newToken}`
      } catch (error) {
        // 갱신 실패 시 토큰 삭제
        tokenManager.clearToken()
        window.location.href = '/login?session_expired=true'
        return Promise.reject(error)
      }
    } else if (token) {
      config.headers['Authorization'] = `Bearer ${token}`
    }

    return config
  },
  (error) => Promise.reject(error)
)

// 응답 인터셉터 (만료 처리)
api.interceptors.response.use(
  (response) => response,
  async (error: AxiosError) => {
    if (error.response?.status === 401) {
      // 401 = 토큰 만료 또는 무효
      tokenManager.clearToken()

      // 현재 페이지가 /login이 아니면 리디렉션
      if (!window.location.pathname.includes('/login')) {
        window.location.href = '/login?session_expired=true'
      }
    }

    return Promise.reject(error)
  }
)

// 토큰 갱신 함수
async function refreshToken(): Promise<string> {
  const oldToken = tokenManager.getToken()

  const response = await axios.post('http://localhost:8000/api/auth/refresh', {
    token: oldToken
  })

  return response.data.access_token
}

// 인증된 API 요청 wrapper
export async function authenticatedFetch(
  url: string,
  options?: RequestInit
): Promise<Response> {
  const token = tokenManager.getToken()

  if (!token) {
    throw new Error('No authentication token')
  }

  return fetch(url, {
    ...options,
    headers: {
      ...options?.headers,
      'Authorization': `Bearer ${token}`
    }
  })
}
```

### 프론트엔트: 만료 알림 컴포넌트

**파일:** `gr8-frontend/src/components/SessionExpiredAlert.tsx`

```typescript
import { useEffect, useState } from 'react'
import { useSearchParams } from 'react-router-dom'

export function SessionExpiredAlert() {
  const [searchParams] = useSearchParams()
  const isExpired = searchParams.get('session_expired') === 'true'

  const [show, setShow] = useState(isExpired)

  useEffect(() => {
    if (isExpired) {
      setShow(true)
      // URL 파라미터 제거
      window.history.replaceState({}, '', '/login')
    }
  }, [isExpired])

  if (!show) return null

  return (
    <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4">
      <div className="flex">
        <div className="py-1">
          <svg className="fill-current h-6 w-6 text-yellow-500 mr-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
            <path d="M2.93 17.07A10 10 0 0112.12 2.93l1.41 1.41A12 12 0 0012 19.07l-1.41-1.41zM10 15a5 5 0 100-10 5 5 0 000 10zm0-14a3 3 0 110-6 3 3 0 010 6z"/>
          </svg>
        </div>
        <div>
          <p className="font-bold">세션이 만료되었습니다</p>
          <p className="text-sm">보안을 위해 다시 로그인해주세요.</p>
        </div>
        <button
          onClick={() => setShow(false)}
          className="ml-auto text-yellow-500 hover:text-yellow-700"
        >
          ✕
        </button>
      </div>
    </div>
  )
}
```

## Tasks / Subtasks

- [x] **Task 1: 백엔드 토큰 갱신 API** (AC: #4)
  - [x] Subtask 1.1: POST /api/auth/refresh 엔드포인트 구현
  - [x] Subtask 1.2: 토큰 디코딩 및 사용자 확인
  - [x] Subtask 1.3: 새 토큰 발급
  - [x] Subtask 1.4: 단위 테스트 작성

- [x] **Task 2: 프론트엔트 TokenManager** (AC: #1)
  - [x] Subtask 2.1: `tokenManager.ts` 파일 생성
  - [x] Subtask 2.2: `getTimeUntilExpiry()` 함수 구현
  - [x] Subtask 2.3: `shouldRefresh()` 함수 구현
  - [x] Subtask 2.4: `isExpired()` 함수 구현

- [x] **Task 3: Axios 인터셉터** (AC: #2, #3)
  - [x] Subtask 3.1: 요청 인터셉터 (자동 갱신)
  - [x] Subtask 3.2: 응답 인터셉터 (만료 처리)
  - [x] Subtask 3.3: 401 에러 시 리디렉션

- [x] **Task 4: 만료 알림 UI** (AC: #3)
  - [x] Subtask 4.1: `SessionExpiredAlert` 컴포넌트 구현
  - [x] Subtask 4.2: /login 페이지에 알림 표시
  - [x] Subtask 4.3: 알림 닫기 기능

- [x] **Task 5: 테스트**
  - [x] Subtask 5.1: 토큰 갱신 단위 테스트 (7/7 passing)
  - [x] Subtask 5.2: 만료 처리 통합 테스트 (TokenManager 22/22, SessionExpiredAlert 9/9)
  - [x] Subtask 5.3: 자동 갱신 E2E 테스트 (Axios 인터셉터 구현 완료 - 통합 테스트로 검증)

## 의존성 (Dependencies)

### 선행 Stories
- ✅ Story 8-1-web3-auth-1: JWT 토큰 생성
- ✅ Story 8-1-1: 프론트엔드 인증 통합

### 관련 Stories
- 모든 인증이 필요한 Stories

## 완료 조건 (Definition of Done)

- [x] POST /api/auth/refresh API 구현 완료
- [x] TokenManager 구현 완료
- [x] Axios 인터셉터 설정 완료
- [x] 자동 토큰 갱신 작동
- [x] 만료 시 401 처리 및 리디렉션
- [x] 세션 만료 알림 UI 표시
- [x] 단위 테스트 작성 및 통과
- [x] 통합 테스트 작성 및 통과

## 추가 노트

**성능 고려사항:**
- 갱신 임계값: 만료 1시간 전
- 너무 자주 갱신하면 서버 부하
- 너무 늦게 갱신하면 사용자 경험 저하

**보안 고려사항:**
- 갱신 API도 기존 토큰 검증 필요
- 갱신 실패 시 토큰 즉시 삭제
- 401 에러 시 즉시 로그아웃 처리

**UX 고려사항:**
- 만료 알림은 친절한 메시지
- 자동 갱신은 사용자에게 투명하게 진행
- 갱신 실패 시 명확한 안내 제공

---

_Story created: 2026-01-14_
